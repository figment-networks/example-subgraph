type Block @entity {
  id: ID!
  header: Header
  evidence: EvidenceList
  lastCommit: Commit
  resultBeginBlock: ResponseBeginBlock
  resultEndBlock: ResponseEndBlock
  transactions: [TxResult!]
  validatorUpdates: [Validator!]
}

type HeaderOnlyBlock @entity {
  id: ID!
  header: Header
}

type EventData @entity {
  id: ID!
  event: Event
  block: HeaderOnlyBlock
}

type TransactionData @entity {
  id: ID!
  tx: TxResult
  block: HeaderOnlyBlock
}

type Header @entity {
  id: ID!
  version: Consensus
  chainId: String
  height: BigInt
  time: Timestamp
  lastBlockId: BlockID
  lastCommitHash: Bytes
  dataHash: Bytes
  validatorsHash: Bytes
  nextValidatorsHash: Bytes
  consensusHash: Bytes
  appHash: Bytes
  lastResultsHash: Bytes
  evidenceHash: Bytes
  proposerAddress: Bytes
  hash: Bytes
}

type Consensus @entity {
  id: ID!
  block: BigInt
  app: BigInt
}

type Timestamp @entity {
  id: ID!
  seconds: BigInt
  nanos: Int
}

type BlockID @entity {
  id: ID!
  hash: Bytes
  partSetHeader: PartSetHeader
}

type PartSetHeader @entity {
  id: ID!
  total: BigInt
  hash: Bytes
}

type EvidenceList @entity {
  id: ID!
  evidence: [Evidence!]
}

type Evidence @entity {
  id: ID!
  duplicateVoteEvidence: DuplicateVoteEvidence
  lightClientAttackEvidence: LightClientAttackEvidence
}

type DuplicateVoteEvidence @entity {
  id: ID!
  voteA: EventVote
  voteB: EventVote
  totalVotingPower: BigInt
  validatorPower: BigInt
  timestamp: Timestamp
}

type EventVote @entity {
  id: ID!
  eventVoteType: SignedMsgType
  height: BigInt
  round: Int
  blockId: BlockID
  timestamp: Timestamp
  validatorAddress: Bytes
  validatorIndex: Int
  signature: Bytes
}

enum SignedMsgType {
  SIGNED_MSG_TYPE_UNKNOWN
  SIGNED_MSG_TYPE_PREVOTE
  SIGNED_MSG_TYPE_PRECOMMIT
  SIGNED_MSG_TYPE_PROPOSAL
}

type LightClientAttackEvidence @entity {
  id: ID!
  conflictingBlock: LightBlock
  commonHeight: BigInt
  byzantineValidators: [Validator!]
  totalVotingPower: BigInt
  timestamp: Timestamp
}

type LightBlock @entity {
  id: ID!
  signedHeader: SignedHeader
  validatorSet: ValidatorSet
}

type SignedHeader @entity {
  id: ID!
  header: Header
  commit: Commit
}

type Commit @entity {
  id: ID!
  height: BigInt
  round: Int
  blockId: BlockID
  signatures: [CommitSig!]
}

type CommitSig @entity {
  id: ID!
  blockIdFlag: BlockIDFlag
  validatorAddress: Bytes
  timestamp: Timestamp
  signature: Bytes
}

enum BlockIDFlag {
  BLOCK_ID_FLAG_UNKNOWN
  BLOCK_ID_FLAG_ABSENT
  BLOCK_ID_FLAG_COMMIT
  BLOCK_ID_FLAG_NIL
}

type ValidatorSet @entity {
  id: ID!
  validators: [Validator!]
  proposer: Validator
  totalVotingPower: BigInt
}

type Validator @entity {
  id: ID!
  address: Bytes
  pubKey: PublicKey
  votingPower: BigInt
  proposerPriority: BigInt
}

type PublicKey @entity {
  id: ID!
  ed25519: Bytes
  secp256k1: Bytes
}

type ResponseBeginBlock @entity {
  id: ID!
  events: [Event!]
}

type Event @entity {
  id: ID!
  eventType: String
  attributes: [EventAttribute!]
}

type EventAttribute @entity {
  id: ID!
  key: String
  value: String
  index: Boolean
}

type ResponseEndBlock @entity {
  id: ID!
  validatorUpdates: [ValidatorUpdate!]
  consensusParamUpdates: ConsensusParams
  events: [Event!]
}

type ValidatorUpdate @entity {
  id: ID!
  address: Bytes
  pubKey: PublicKey
  power: BigInt
}

type ConsensusParams @entity {
  id: ID!
  block: BlockParams
  evidence: EvidenceParams
  validator: ValidatorParams
  version: VersionParams
}

type BlockParams @entity {
  id: ID!
  maxBytes: BigInt
  maxGas: BigInt
}

type EvidenceParams @entity {
  id: ID!
  maxAgeNumBlocks: BigInt
  maxAgeDuration: Duration
  maxBytes: BigInt
}

type Duration @entity {
  id: ID!
  seconds: BigInt
  nanos: Int
}

type ValidatorParams @entity {
  id: ID!
  pubKeyTypes: [String!]
}

type VersionParams @entity {
  id: ID!
  appVersion: BigInt
}

type TxResult @entity {
  id: ID!
  height: BigInt
  index: BigInt
  tx: Tx
  result: ResponseDeliverTx
  hash: Bytes
}

type Tx @entity {
  id: ID!
  body: TxBody
  authInfo: AuthInfo
  signatures: [Bytes!]
}

type TxBody @entity {
  id: ID!
  messages: [Message!]
  memo: String
  timeoutHeight: BigInt
  extensionOptions: [ExtensionOption!]
  nonCriticalExtensionOptions: [ExtensionOption!]
}

type Message implements Any @entity {
  id: ID!
  index: Int!
  typeUrl: String
  value: Bytes
}

type ExtensionOption implements Any @entity {
  id: ID!
  index: Int!
  typeUrl: String
  value: Bytes
}

type PublicKeyAny implements Any @entity {
  id: ID!
  typeUrl: String
  value: Bytes
}

interface Any {
  id: ID!
  typeUrl: String
  value: Bytes
}

type AuthInfo @entity {
  id: ID!
  signerInfos: [SignerInfo!]
  fee: Fee
  tip: Tip
}

type SignerInfo @entity {
  id: ID!
  publicKey: PublicKeyAny
  modeInfo: ModeInfo
  sequence: BigInt
}

type ModeInfo @entity {
  id: ID!
  single: ModeInfoSingle
  multi: ModeInfoMulti
}

type ModeInfoSingle @entity {
  id: ID!
  mode: SignMode
}

enum SignMode {
  SIGN_MODE_UNSPECIFIED
  SIGN_MODE_DIRECT
  SIGN_MODE_TEXTUAL
  SIGN_MODE_LEGACY_AMINO_JSON
}

type ModeInfoMulti @entity {
  id: ID!
  bitarray: CompactBitArray
  modeInfos: [ModeInfo!]
}

type CompactBitArray @entity {
  id: ID!
  extraBitsStored: BigInt
  elems: Bytes
}

type Fee @entity {
  id: ID!
  amount: [Coin!]
  gasLimit: BigInt
  payer: String
  granter: String
}

type Coin @entity {
  id: ID!
  denom: String
  amount: String
}

type Tip @entity {
  id: ID!
  amount: [Coin!]
  tipper: String
}

type ResponseDeliverTx @entity {
  id: ID!
  code: BigInt
  data: Bytes
  log: String
  info: String
  gasWanted: BigInt
  gasUsed: BigInt
  events: [Event!]
  codespace: String
}

type ValidatorSetUpdates @entity {
  id: ID!
  validatorUpdates: [Validator!]
}

# From here on, these are the custom types for handlers and messages.
"Reward is not auto-generated but necessary"
type Reward @entity {
  id: ID!
  amount: String
  validator: String
}

type PubKey @entity {
  id: ID!
  key: Bytes
}

enum State {
  STATE_UNINITIALIZED_UNSPECIFIED
  STATE_INIT
  STATE_TRYOPEN
  STATE_OPEN
  STATE_CLOSED
}

enum Order {
  ORDER_NONE_UNSPECIFIED
  ORDER_UNORDERED
  ORDER_ORDERED
}

enum VoteOption {
  VOTE_OPTION_UNSPECIFIED
  VOTE_OPTION_YES
  VOTE_OPTION_ABSTAIN
  VOTE_OPTION_NO
  VOTE_OPTION_NO_WITH_VETO
}

type MsgSend @entity {
  id: ID!
  fromAddress: String
  toAddress: String
  amount: [Coin!]
}

type MsgMultiSend implements Any @entity {
  id: ID!
  inputs: [Input!]
  outputs: [Output!]
  typeUrl: String
  value: Bytes
}

type MsgVerifyInvariant implements Any @entity {
  id: ID!
  sender: String
  invariantModuleName: String
  invariantRoute: String
  typeUrl: String
  value: Bytes
}

type MsgSetWithdrawAddress implements Any @entity {
  id: ID!
  delegatorAddress: String
  withdrawAddress: String
  typeUrl: String
  value: Bytes
}

type MsgWithdrawDelegatorReward implements Any @entity {
  id: ID!
  delegatorAddress: String
  validatorAddress: String
  typeUrl: String
  value: Bytes
}

type MsgWithdrawValidatorCommission implements Any @entity {
  id: ID!
  validatorAddress: String
  typeUrl: String
  value: Bytes
}

type MsgFundCommunityPool implements Any @entity {
  id: ID!
  amount: [Coin!]
  depositor: String
  typeUrl: String
  value: Bytes
}

type MsgSubmitEvidence implements Any @entity {
  id: ID!
  submitter: String
  evidence: Any
  typeUrl: String
  value: Bytes
}

type MsgSubmitProposal implements Any @entity {
  id: ID!
  content: Any
  initialDeposit: [Coin!]
  proposer: String
  typeUrl: String
  value: Bytes
}

type MsgVote implements Any @entity {
  id: ID!
  proposalId: BigInt
  voter: String
  option: VoteOption
  typeUrl: String
  value: Bytes
}

type MsgDeposit implements Any @entity {
  id: ID!
  proposalId: BigInt
  depositor: String
  amount: [Coin!]
  typeUrl: String
  value: Bytes
}

type MsgUnjail implements Any @entity {
  id: ID!
  validatorAddr: String
  typeUrl: String
  value: Bytes
}

type MsgCreateValidator implements Any @entity {
  id: ID!
  description: Description
  commission: CommissionRates
  minSelfDelegation: String
  delegatorAddress: String
  validatorAddress: String
  pubkey: PublicKeyAny
  amount: Coin
  typeUrl: String
  value: Bytes
}

type MsgEditValidator implements Any  @entity {
  id: ID!
  description: Description
  validatorAddress: String
  commissionRate: String
  minSelfDelegation: String
  typeUrl: String
  value: Bytes
}

type MsgDelegate implements Any  @entity {
  id: ID!
  delegatorAddress: String
  validatorAddress: String
  amount: Coin
  typeUrl: String
  value: Bytes
}

type MsgBeginRedelegate implements Any  @entity {
  id: ID!
  delegatorAddress: String
  validatorSrcAddress: String
  validatorDstAddress: String
  amount: Coin
  typeUrl: String
  value: Bytes
}

type MsgUndelegate implements Any  @entity {
  id: ID!
  delegatorAddress: String
  validatorAddress: String
  amount: Coin
  typeUrl: String
  value: Bytes
}

type MsgCreateVestingAccount implements Any  @entity {
  id: ID!
  fromAddress: String
  toAddress: String
  amount: Coin
  endTime: BigInt
  delayed: Boolean
  typeUrl: String
  value: Bytes
}

type MsgTransfer implements Any  @entity {
  id: ID!
  sourcePort: String
  sourceChannel: String
  token: Coin
  sender: String
  receiver: String
  timeoutHeight: Height
  timeoutTimestamp: BigInt
  typeUrl: String
  value: Bytes
}

type MsgChannelOpenInit implements Any @entity {
  id: ID!
  portId: String
  channel: Channel
  signer: String
  typeUrl: String
  value: Bytes
}

type MsgChannelOpenTry implements Any @entity {
  id: ID!
  portId: String
  previousChannelId: String
  channel: Channel
  counterpartyVersion: String
  proofInit: Bytes
  proofHeight: Height
  signer: String
  typeUrl: String
  value: Bytes
}

type MsgChannelOpenAck implements Any @entity {
  id: ID!
  portId: String
  channelId: String
  counterpartyChannelId: String
  counterpartyVersion: String
  proofTry: Bytes
  proofHeight: Height
  signer: String
  typeUrl: String
  value: Bytes
}

type MsgChannelOpenConfirm implements Any @entity {
  id: ID!
  portId: String
  channelId: String
  proofAck: Bytes
  proofHeight: Height
  signer: String
  typeUrl: String
  value: Bytes
}

type MsgChannelCloseInit implements Any @entity {
  id: ID!
  portId: String
  channelId: String
  signer: String
  typeUrl: String
  value: Bytes
}

type MsgChannelCloseConfirm implements Any @entity {
  id: ID!
  portId: String
  channelId: String
  proofInit: Bytes
  proofHeight: Height
  signer: String
  typeUrl: String
  value: Bytes
}

type MsgRecvPacket implements Any @entity {
  id: ID!
  packet: Packet
  proofCommitment: Bytes
  proofHeight: Height
  signer: String
  typeUrl: String
  value: Bytes
}

type MsgTimeout implements Any @entity {
  id: ID!
  packet: Packet
  proofUnreceived: Bytes
  proofHeight: Height
  nextSequenceRecv: BigInt
  signer: String
  typeUrl: String
  value: Bytes
}

type MsgTimeoutOnClose implements Any @entity {
  id: ID!
  packet: Packet
  proofUnreceived: Bytes
  proofClose: Bytes
  proofHeight: Height
  nextSequenceRecv: BigInt
  signer: String
  typeUrl: String
  value: Bytes
}

type MsgAcknowledgement implements Any @entity {
  id: ID!
  packet: Packet
  acknowledgement: Bytes
  proofAcked: Bytes
  proofHeight: Height
  signer: String
  typeUrl: String
  value: Bytes
}

type MsgCreateClient implements Any @entity {
  id: ID!
  clientState: Any
  consensusState: Any
  signer: String
  typeUrl: String
  value: Bytes
}

type MsgUpdateClient implements Any @entity {
  id: ID!
  clientId: String
  header: Any
  signer: String
  typeUrl: String
  value: Bytes
}

type MsgUpgradeClient implements Any @entity {
  id: ID!
  clientId: String
  clientState: Any
  consensusState: Any
  proofUpgradeClient: Bytes
  proofUpgradeConsensusState: Bytes
  signer: String
  typeUrl: String
  value: Bytes
}

type MsgSubmitMisbehaviour implements Any @entity {
  id: ID!
  clientId: String
  misbehaviour: Any
  signer: String
  typeUrl: String
  value: Bytes
}

type MsgConnectionOpenInit implements Any @entity {
  id: ID!
  clientId: String
  counterparty: ConnectionCounterparty
  version: ConnectionVersion
  delayPeriod: BigInt
  signer: String
  typeUrl: String
  value: Bytes
}

type MsgConnectionOpenTry implements Any @entity {
  id: ID!
  clientId: String
  previousConnectionId: String
  clientState: Any
  counterparty: ConnectionCounterparty
  delayPeriod: BigInt
  counterpartyVersions: [ConnectionVersion!]
  proofHeight: Height
  proofInit: Bytes
  proofClient: Bytes
  proofConsensus: Bytes
  consensusHeight: Height
  signer: String
  typeUrl: String
  value: Bytes
}

type MsgConnectionOpenAck implements Any @entity {
  id: ID!
  connectionId: String
  counterpartyConnectionId: String
  version: ConnectionVersion
  clientState: Any
  proofHeight: Height
  proofTry: Bytes
  proofClient: Bytes
  proofConsensus: Bytes
  consensusHeight: Height
  signer: String
  typeUrl: String
  value: Bytes
}

type MsgConnectionOpenConfirm implements Any @entity {
  id: ID!
  connectionId: String
  proofAck: Bytes
  proofHeight: Height
  signer: String
  typeUrl: String
  value: Bytes
}

type Channel @entity {
  id: ID!
  state: State
  ordering: Order
  counterparty: ChannelCounterparty
  connectionHops: [String!]
  version: String
}

type ChannelCounterparty @entity {
  id: ID!
  portId: String
  channelId: String
}

type CommissionRates @entity {
  id: ID!
  rate: String
  maxRate: String
  maxChangeRate: String
}

type ConnectionCounterparty @entity {
  id: ID!
  clientId: String
  connectionId: String
  prefix: MerklePrefix
}

type ConnectionVersion @entity {
  id: ID!
  identifier: String
  features: [String!]
}

type Description @entity {
  id: ID!
  moniker: String
  identity: String
  website: String
  securityContact: String
  details: String
}

type Height @entity {
  id: ID!
  revisionNumber: BigInt
  revisionHeight: BigInt
}

type Input @entity {
  id: ID!
  address: String
  coins: [Coin!]
}

type Output @entity {
  id: ID!
  address: String
  coins: [Coin!]
}

type MerklePrefix @entity {
  id: ID!
  keyPrefix: Bytes
}

type Packet @entity {
  id: ID!
  sequence: BigInt
  sourcePort: String
  sourceChannel: String
  destinationPort: String
  destinationChannel: String
  data: Bytes
  timeoutHeight: Height
  timeoutTimestamp: BigInt
}

type CosmosHeader @entity {
  id: ID!
  signedHeader: SignedHeader
  validatorSet: ValidatorSet
  trustedHeight: Height
  trustedValidators: ValidatorSet
}

type Delegation @entity {
  id: ID!
  delegatorAddress: String
  validatorAddress: String
  amount: Coin
}
